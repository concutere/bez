<!DOCTYPE html>
<html>
  <head>

    <script>
    

      var bezSize = 4096;
      
      var includeSvgPath = false;
      

</script>
    <script src="dft.js"></script>
    
    <script>
      //basic audio setup
          var getCtx = (function() {
        var ctx = new AudioContext();
        return function() { return ctx; };
      })();
        
    function scaleHz(val, max, octaves) {
      return Math.pow(2,(max-val) / (max/octaves))
    } 

    var hz, minHz=110, initHz=261.625565; //middle C
    var newWave=undefined;
    function stream() {
      var ctx = getCtx();
      var gain = ctx.createGain();

      var oscillator = ctx.createOscillator();
      gain.gain.value=1;
      oscillator.type = 'custom';
      
 
      oscillator.connect(gain);
      gain.connect(ctx.destination);
      if (isNaN(hz))
        oscillator.frequency.value=hz=initHz;
      
      var recur = function recur() {
        if (isNaN(hz)) {
          try {
            oscillator.stop();
            gain.disconnect();
          } catch(e) { }
          return;
        }
        else {
          if(newWave) {
            oscillator.setPeriodicWave(newWave);
            newWave = undefined;
          }
          oscillator.frequency.value = hz;
          requestAnimationFrame(recur);
        }
      };

      oscillator.start();
      requestAnimationFrame(recur);
    }

</script>

    <script>
      //bezier functions
function expand(pts, size) {
  function cubic(x0,x1,x2,x3,t) {
    //TODO derive coefficients from an arbitrary length list of points
    return Math.pow(1-t,3) * x0 +
           Math.pow(1-t,2) * 3 * t * x1 +
           Math.pow(t,2) * 3 * (1 - t) * x2 +
           Math.pow(t,3) * x3;
  }
  function quad(x0,x1,x2,t) {
    return Math.pow(1-t,2) * x0 +
           2*t*(1-t) * x1 +
           t*t * x2;
  }
  
  if (pts.length > 4) {
    //see commented out P at bottom to handle any # of pts for a single higher-order beziercurve/bernstein poly
    
    //break down into multiple 3pt quad curves and call expand on each
    //subdivide t accordingly for the accumulated expand calls
    var last = pts[0];
    var acc=[];
    var tsize = Math.floor(size/(pts.length-2));
    for (var p = 1; p < pts.length-2; p++) {
      var midp = {x: (pts[p].x+pts[p+1].x)/2, 
                  y: (pts[p].y+pts[p+1].y)/2};
      var seg = [last,pts[p],midp];
      acc=acc.concat(expand(seg,tsize));
      last = midp;
    }
    acc=acc.concat(expand([last,pts[pts.length-2],pts[pts.length-1]],tsize));
    if (acc.length>size)
      acc=acc.slice(0,4096);
    else 
      while (acc.length<size) 
        acc.push(acc[acc.length-1]);

    return acc;
  }
  var ts = [];
  for (var t = 0.0; t < 1; t+=1/size) {
    if (pts.length==4) {
      var bx = cubic(pts[0].x,pts[1].x,pts[2].x,pts[3]
      .x, t);
      var by = cubic(pts[0].y,pts[1].y,pts[2].y,pts[3].y, t);
      ts.push({x: bx, y: by});
    } else if(pts.length == 3) {
      var bx = quad(pts[0].x,pts[1].x,pts[2].x, t);
      var by = quad(pts[0].y,pts[1].y,pts[2].y, t);
      ts.push({x: bx, y: by});
    }
  }
  return ts;
}

function reWave(pts,h,w) {
  var ctx = getCtx();
  var cpts = expand(pts,bezSize);
  var svg = document.getElementById('boo');
  var vals=vals||new Float32Array(cpts.length);
  for (var i = 0; i < cpts.length; i++) {
    if(i % (cpts.length/64) == 0) 
      addBC(svg,i,cpts[i].x,cpts[i].y);
    // using x can be good for "interesting" control options, less so for making sense of the math
    vals[i]=cpts[i].y;
  }

  var fft = new FFT(bezSize);
  var trans = fft.forward(vals);
  return ctx.createPeriodicWave(trans.real,trans.imag);
}
    </script>
    
    <script>
    //SVG stuff
      var op = 'S'; //using S w/o slice (below) gives all pts on the actual curve
      //C w/ slice(1) on pts.join below
    function getD(pts) {

        return "M " + pts[0].x + ", " + pts[0].y + ' ' + op + ' ' + pts.join(", ");
    }
    var svgNS = "http://www.w3.org/2000/svg";
    function addControl(svg,name, x, y) {
      var p = document.createElementNS(svgNS,"circle");
      svg.appendChild(p);
      p.id = name;
      p.setAttribute('stroke','blue');
      p.setAttribute('fill','red');
      p.setAttribute('cx', x);
      p.setAttribute('cy', y);
      p.setAttribute('r', 25);
      return p;
    }
      
    function addBC(svg,name, x, y) {
      var p = document.getElementById('bc'+name) || document.createElementNS(svgNS,"circle");
      svg.appendChild(p);
      p.id = 'bc'+name;
      p.setAttribute('stroke','#0f0');
      p.setAttribute('strokeThickness',1);
      p.setAttribute('fill','transparent');
      p.setAttribute('cx', x);
      p.setAttribute('cy', y);
      p.setAttribute('r', 5);
      return p;
    }
      
    function addPath(svg,pts) {
      var p = document.createElementNS(svgNS,"path");
      svg.appendChild(p);
      p.id='path';
      p.setAttribute('stroke','black');
      p.setAttribute('strokeThickness',5);
      p.setAttribute('fill','transparent');
      p.setAttribute('d',getD(pts));

      return p;
    }
    
    function rePath(svg,pts) {
    if (!includeSvgPath) return;
      var currP = document.getElementById('path');
      if(currP) {
        var d = getD(pts);
        currP.setAttribute('d', d);
      }
    }

    var pts=[];
    function init(e) {
      var controlpts=8;
      var svg = document.getElementById('boo');
      var w = svg.width.baseVal.value;
      var h = svg.height.baseVal.value;
      if(w == 0 || h == 0) {
        setTimeout(init,1);
        return;
      }
      var yy = h/2;
      pts=[];
      //pts=[{x:0,y:yy}];
      for (var i = 0; i <= 1; i+=1/(controlpts-1)) {
        var xx = Math.round(i * w)
        var pt = { x: xx, y: yy };
        pts.push(pt);
      }
      //pts.push({x:w,y:yy})
      pts.forEach(function(v,i,a) {
        v['toString'] = function() { return this.x + ' ' + this.y; };
      });
      
      if (includeSvgPath) 
        addPath(svg,pts);
      
      for (var i = 1; i < pts.length-1; i++) {
        addControl(svg,'control'+(i),pts[i].x, pts[i].y);      
      }
    }
    </script>
    <style>
    </style>
  </head>
  <body>
    <svg id=boo width="100%" height="100%" style="position:absolute;top:0px;left:0px;margin:0px;padding:0px;border:0px">

    </svg>
  </body>
  <script>
    //event handlers
    var boo = document.getElementById('boo');
    var ctlid = undefined;
    document.addEventListener('mousedown', down);
    document.addEventListener('touchstart', function (e) {
      down(e.touches[0]);
    });
    function down (e) { 
      if(e.srcElement.id.indexOf('control')==0) {
        ctlid = parseInt(e.srcElement.id.substr(7));
      }
    }
    document.addEventListener('mouseup', up);
    document.addEventListener('touchend', up);
    
    function up(e) {
      hz=undefined;
      ctlid = undefined;
    }
    
    document.addEventListener('mousemove',function(e) {
      if (e.which == 0) {
        // no clicky, no draggy
        return;
      }
      move(e);
    });
    
    document.addEventListener('touchmove',function(e) {
      move(e.touches[0]);
    });
    function move(e) {
      if (ctlid == undefined)
        return;
        
      if (isNaN(hz)) {
        stream();
      }
      var h = boo.height.baseVal.value;
      var w = boo.width.baseVal.value;
      var x = e.clientX;
      var y = e.clientY;
      var id = e.srcElement.id;
      if(ctlid >0 && ctlid < pts.length-1) {
        var i = ctlid;
        var ctl = document.getElementById('control'+ctlid);
        var pt= pts[ctlid];
        pt.x = x;
        pt.y = y;
        ctl.setAttribute('cx',x);
        ctl.setAttribute('cy',y);

        rePath(boo,pts);
        newWave = reWave(pts,h,w); //h/2,w/2);
      }
      //var ratio = scaleHz(y,h,2);//Math.log(1+(h-y)/h)*4;
      //hz=ratio*minHz; 
    }
    document.addEventListener('DOMContentLoaded', init);

//    ////////////////////////////////////
//    //n-degree bernstein func
//        /**Computes factorial*/
//function fact(k){
//    if(k==0 || k==1){
//	return 1;
//    }
//    else{
//	return k * fact(k-1);
//    }
//}
//
///**Computes Bernstain
//*@param {Integer} i - the i-th index
//*@param {Integer} n - the total number of points
//*@param {Number} t - the value of parameter t , between 0 and 1
//**/
//function B(i,n,t){
//    //if(n < i) throw "Wrong";
//    return fact(n) / (fact(i) * fact(n-i))* Math.pow(t, i) * Math.pow(1-t, n-i);
//}                            
//
//
///**Computes a point's coordinates for a value of t
//*@param {Number} t - a value between o and 1
//*@param {Array} points - an {Array} of [x,y] coodinates. The initial points
//**/
//function P(t, points){
//    var r = {x:0,y:0};
//    var n = points.length-1;
//    for(var i=0; i <= n; i++){
//	r.x += points[i].x * B(i, n, t);
//	r.y += points[i].y * B(i, n, t);
//    }                
//    return r;
//}

  </script>
</html>